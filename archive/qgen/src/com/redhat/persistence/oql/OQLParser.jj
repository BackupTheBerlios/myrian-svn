options {
    STATIC = false;
    DEBUG_PARSER = false;
}

PARSER_BEGIN(OQLParser)

package com.redhat.persistence.oql;

import java.lang.reflect.*;
import java.math.*;
import java.util.*;
import java.io.*;

/**
 * OQLParser
 *
 * @author <a href="mailto:rhs@mit.edu">rhs@mit.edu</a>
 * @version $Revision: #6 $ $Date: 2004/01/27 $
 */

class OQLParser {

    private static Map EXPRESSIONS = new HashMap();

    static {
        EXPRESSIONS.put("join", Join.class);
        EXPRESSIONS.put("left", LeftJoin.class);
        EXPRESSIONS.put("right", RightJoin.class);
        EXPRESSIONS.put("cross", CrossJoin.class);
        EXPRESSIONS.put("full", FullJoin.class);
        EXPRESSIONS.put("filter", Filter.class);
        EXPRESSIONS.put("sort", Sort.class);
        EXPRESSIONS.put("offset", Offset.class);
        EXPRESSIONS.put("limit", Limit.class);
        EXPRESSIONS.put("exists", Exists.class);
        EXPRESSIONS.put("size", Size.class);
    }

    static Expression construct(Token t, List args) {
        Class klass = (Class) EXPRESSIONS.get(t.image);
        if (klass == null) {
            throw new IllegalArgumentException
                ("no such expression: " + t.image);
        }
        Class[] params = new Class[args.size()];
        for (int i = 0; i < params.length; i++) {
            params[i] = Expression.class;
        }
        try {
            Constructor cons = klass.getDeclaredConstructor(params);
            return (Expression) cons.newInstance(args.toArray());
        } catch (NoSuchMethodException e) {
            throw new IllegalStateException
                ("no such method: " + t.image + Arrays.asList(params));
        } catch (InstantiationException e) {
            throw new IllegalStateException(e.getMessage());
        } catch (IllegalAccessException e) {
            throw new IllegalStateException(e.getMessage());
        } catch (InvocationTargetException e) {
            throw new IllegalStateException(e.getMessage());
        }
    }

    static String parseString(String image) {
        StringBuffer result = new StringBuffer(image.length());
        for (int i = 0; i < image.length(); i++) {
            char c = image.charAt(i);
            if (c == '\\') { c = image.charAt(++i); }
            result.append(c);
        }
        return result.toString();
    }

}

PARSER_END(OQLParser)

<DEFAULT,BEGIN> SKIP:
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}

TOKEN:
{
    <LPAREN: "(">
  | <RPAREN: ")">
  | <COMMA: ",">
  | <DOT: ".">
  | <EQ: "=">
  | <EQUALS: "==">
  | <AND: "and">
  | <OR: "or">
  | <NOT: "not">
  | <STATIC: "static"> : BEGIN
  | <ALL: "all">
}

TOKEN:
{
    <#CH: <ESC>|<CHARS>>
  | <#CHARS: ["a" - "z", "A" - "Z", "_", "$"]>
  | <#ESC: "\\" ~[]>
  | <#DIGIT: ["0" - "9"]>
  | <STRING: "\"" ( ~["\""] | "\\\"" )* "\"">
  | <INTEGER: ( "+" | "-" )? (<DIGIT>)+>
  | <DECIMAL: ( "+" | "-" )? (<DIGIT>)* ( "." (<DIGIT>)+ )?
              ( "E" | "e" ) ( "+" | "-" ) (<DIGIT>)+>
  | <BOOLEAN: ( "true" | "false" )>
  | <ID: (<CH>) (<CH>|<DIGIT>)* ( "[]" )?>
}

<BEGIN> MORE:
{
  <"{"> { image.deleteCharAt(image.length() - 1); } : INSQL
}

<INSQL> TOKEN:
{
    <SQL: "}">
    {
        image.deleteCharAt(image.length() - 1);
        matchedToken.image = image.toString();
    } : DEFAULT
}

<INSQL> MORE:
{
    <~[]>
}

SPECIAL_TOKEN:
{
    <COMMENT: "//" (~["\n", "\r"])* ("\n"|"\r"|"\r\n")>
}

/**
 * Top level constructs.
 **/

Expression expression() :
{
    Expression e;
}
{
    e = define() { return e; } | <EOF> { return null; }
}

Expression define() :
{
    Expression e;
    Token t = null;
}
{
    [ LOOKAHEAD(2) t = <ID> <EQ> ] e = binary()
        { return  t == null ? e : new Define(e, t.image); }
}

Expression binary() :
{
    Expression e;
}
{
    e = or() { return e; }
}

Expression or() :
{
    Expression l, r;
}
{
    l = and() [ <OR> r = or() { return new Or(l, r); } ] { return l; }
}

Expression and() :
{
    Expression l, r;
}
{
    l = equals() [ <AND> r = and() { return new And(l, r); } ] { return l; }
}

Expression equals() :
{
    Expression l, r;
}
{
    l = unary() [ <EQUALS> r = equals() { return new Equals(l, r); } ]
        { return l; }
}

Expression unary() :
{
    Expression e;
}
{
    e = not() { return e; }
}

Expression not() :
{
    Expression e;
    boolean not = false;
}
{
    [ <NOT> { not = true; } ] e = get() { return not ? new Not(e) : e; }
}

Expression get() :
{
    Expression e;
    Token t;
}
{
    e = primitive() ( <DOT> t = <ID> { e = new Get(e, t.image); } )*
        { return e; }
}

Expression primitive() :
{
    Expression e;
}
{
  ( e = generic() | e = parens() )
      { return e; }
}

Expression generic() :
{
    Token t;
    List l;
    Expression e;
}
{
    t = <ID> [ l = exprl() { return construct(t, l); } ]
      { return new Variable(t.image); }
  | <STATIC> t = <SQL>
      { return new Static(t.image); }
  | t = <STRING>
      { return new Literal(parseString(t.image)); }
  | t = <INTEGER>
      { return new Literal(new BigInteger(t.image)); }
  | t = <DECIMAL>
      { return new Literal(new BigDecimal(t.image)); }
  | t = <BOOLEAN>
      { return new Literal(Boolean.valueOf(t.image)); }
  | e = type()
      { return e; }
}

Expression type() :
{
    Token t;
    StringBuffer type = new StringBuffer();
}
{
    <ALL> <LPAREN> t = <ID> { type.append(t.image); }
    ( <DOT> t = <ID> { type.append('.'); type.append(t.image); } )*
    <RPAREN>
        { return new All(type.toString()); }
}

List exprl() :
{
    Expression e;
    List l = new ArrayList();
}
{
    <LPAREN> [ e = expression() { l.add(e); }
               (<COMMA> e = expression() { l.add(e); })* ]<RPAREN>
        { return l; }
}

Expression parens() :
{
    Expression e;
}
{
    <LPAREN> e = expression() <RPAREN> { return e; }
}
