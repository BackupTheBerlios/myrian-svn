options {
    STATIC = false;
    DEBUG_PARSER = false;
}

PARSER_BEGIN(Parser)

package com.arsdigita.persistence.sql;

import java.util.*;

/**
 * Parser
 *
 * @author <a href="mailto:rhs@mit.edu">rhs@mit.edu</a>
 * @version $Revision: #1 $ $Date: 2002/11/27 $
 */

class Parser {

    public final static String versionId = "$Id: //core-platform/proto/src/com/arsdigita/persistence/sql/Parser.jj#1 $ by $Author: dennis $, $DateTime: 2002/11/27 19:51:05 $";

    private String m_filename;

}

PARSER_END(Parser)

<DEFAULT,BEGIN> SKIP:
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}

TOKEN:
{
    <STRING_LITERAL: "'" ( ~["'"] | "''" )* "'">
  | <#DIGIT: ["0" - "9"]>
  | <INTEGER_LITERAL: ( "+" | "-" )? (<DIGIT>)+>
  | <NUMBER_LITERAL: ( "+" | "-" )? (<DIGIT>)* ( "." (<DIGIT>)+ )?
                     ( "E" | "e" ) ( "+" | "-" ) (<DIGIT>)+>
}

TOKEN:
{
    <BINDVAR: ":" ( <ID> | <INTEGER_LITERAL> )>
}

TOKEN:
{
    <LPAREN: "(">
  | <RPAREN: ")">
  | <COMMA: ",">
  | <PERIOD: ".">
  | <SEMI: ";">
  | <MUL: "*">
  | <POS: "+">
  | <NEG: "-">
  | <DIV: "/">
  | <CONCAT: "||"> 
  | <EQ: "=">
  | <NE: ( "!=" | "^=" | "<>" )>
  | <GT: ">">
  | <LT: "<">
  | <LE: "<=">
  | <PUT: "=>">
  | <GE: ">=">
  | <BEGIN_HINT: "/*+">
  | <END_HINT: "*/">
}

TOKEN [IGNORE_CASE]:
{
    <#WS: ([" ", "\t", "\n", "\r", "\f"])+>
  | <NULL: "null">
  | <IS_NULL: "is" <WS> "null">
  | <IS_NOT_NULL: "is" <WS> "not" <WS> "null">
  | <LIKE: "like">
  | <BETWEEN: "between">
  | <IN: "in">
  | <NOT: "not"> 
  | <AND: "and">
  | <OR: "or"> 
  | <ANY: "any">
  | <SOME: "some">
  | <EXISTS: "exists">
  | <UNION: "union">
  | <UNION_ALL: "union" <WS> "all">
  | <INTERSECT: "intersect">
  | <MINUS: "minus">
  | <PRIOR: "prior">
  | <LIMIT: "limit">
  | <OFFSET: "offset">
// Clause beginnings
  | <SELECT: "select">
  | <INSERT_INTO: "insert" <WS> "into">
  | <UPDATE: "update">
  | <DELETE_FROM: "delete" <WS> "from">
  | <FROM: "from">
  | <WHERE: "where">
  | <WITH: "with">
  | <START_WITH: "start" <WS> "with">
  | <CONNECT_BY: "connect" <WS> "by">
  | <GROUP_BY: "group" <WS> "by">
  | <ORDER_BY: "order" <WS> "by">
  | <FOR_UPDATE: "for" <WS> "update">
  | <VALUES: "values">
  | <SET: "set">
}

TOKEN: {
    <ID: <CH>(<CH>|<DIGIT>)*>
  | <#CH: ["a" - "z", "A" - "Z", "_"]>
}

// TODO: Add support for multi-line comments.

SPECIAL_TOKEN:
{
    <COMMENT: "--" (~["\n", "\r"])* ("\n"|"\r"|"\r\n")>
}

Element sql() :
{
    Element el;
    SQL sql = new SQL();
}
{
 [ (  el = statement() { return el; }
    | el = unstructuredElement() { sql.addElement(el); }
      (( el = unstructuredElement() |
         el = clauseStart() ) { sql.addElement(el); })*
      ) ] <EOF> { return sql; }
}

Statement statement() :
{
    Statement result = new Statement();
    Clause clause;
}
{
    ( clause = clause() { result.addClause(clause); } )+
    { return result; }
}

Symbol literal() :
{
    Token t;
}
{
 (  t = <STRING_LITERAL>
  | t = <INTEGER_LITERAL>
  | t = <NUMBER_LITERAL> ) { return Symbol.getInstance(t.image); }
}

Symbol symbol() :
{
    Token t;
}
{
 (
    t = <PERIOD>
  | t = <SEMI>
  | t = <MUL>
  | t = <POS>
  | t = <NEG>
  | t = <DIV>
  | t = <CONCAT> 
  | t = <EQ>
  | t = <NE>
  | t = <GT>
  | t = <LT>
  | t = <LE>
  | t = <PUT>
  | t = <GE>
  | t = <BEGIN_HINT>
  | t = <END_HINT>
  | t = <NULL>
  | t = <IS_NULL>
  | t = <IS_NOT_NULL>
  | t = <LIKE>
  | t = <BETWEEN>
  | t = <IN>
  | t = <NOT> 
  | t = <AND>
  | t = <OR> 
  | t = <ANY>
  | t = <SOME>
  | t = <EXISTS>
  | t = <UNION>
  | t = <UNION_ALL>
  | t = <INTERSECT>
  | t = <LIMIT>
  | t = <OFFSET>
  | t = <MINUS>
  | t = <PRIOR> ) { return Symbol.getInstance(t.image); }
}

Symbol clauseStart() :
{
    Token t;
}
{
 (
    t = <SELECT>
  | t = <INSERT_INTO>
  | t = <UPDATE>
  | t = <DELETE_FROM>
  | t = <FROM>
  | t = <WHERE>
  | t = <WITH>
  | t = <START_WITH>
  | t = <CONNECT_BY>
  | t = <GROUP_BY>
  | t = <ORDER_BY>
  | t = <FOR_UPDATE>
  | t = <VALUES>
  | t = <SET> ) { return Symbol.getInstance(t.image); }
}

Element parens() :
{
    SQL result = new SQL();
    Element el;
    Token t;
}
{
 (  LOOKAHEAD(2) t = <LPAREN> { result.addElement(Symbol.getInstance(t.image)); }
    el = statement() { result.addElement(el); }
    t = <RPAREN> { result.addElement(Symbol.getInstance(t.image)); }
  | t = <LPAREN> { result.addElement(Symbol.getInstance(t.image)); }
    ( el = unstructuredElement() { result.addElement(el); } )*
    t = <RPAREN> { result.addElement(Symbol.getInstance(t.image)); }
    )
   { return result; }
}

Identifier identifier() :
{
    Token t;
    List path = new ArrayList();
}
{
    ( t = <BINDVAR> | t = <ID> ) { path.add(t.image); }
    ( LOOKAHEAD(2) <PERIOD> t = <ID> { path.add(t.image); } ) *
    {
        return Identifier.getInstance((String[]) path.toArray(new String[0]));
    }
}

Element unstructuredElementNoComma() :
{
    Element result;
}
{
  (   result = literal()
    | result = symbol()
    | result = parens()
    | result = identifier()
     ) { return result; }
}

Element unstructuredElement() :
{
    Element el;
    Token t;
}
{
  (  t = <COMMA> { return Symbol.getInstance(t.image); }
   | el = unstructuredElementNoComma()
    ) { return el; }
}

SQL unstructuredSQL() :
{
    SQL result = new SQL();
    Element el;
}
{
    ( el = unstructuredElement() { result.addElement(el); } )*
    { return result; }
}

Clause clause() :
{
    Clause result;
    Symbol start;
    SQL sql;
}
{
 (  LOOKAHEAD(1) result = setClause()
  | start = clauseStart() sql = unstructuredSQL()
    { result =  Clause.getInstance(start, sql); }
    ) { return result; }
}

SetClause setClause() :
{
    SetClause result = new SetClause();
    Assign asn;
}
{
    <SET> asn = assign() { result.addAssign(asn); }
         ( <COMMA> asn = assign() { result.addAssign(asn); } )*
    {
        return result;
    }
}

Assign assign() :
{
    Identifier id;
    Element el;
    SQL rhs = new SQL();
}
{
    id = identifier() <EQ>
    ( el = unstructuredElementNoComma() { rhs.addElement(el); } )+
    { return new Assign(id, rhs); }
}
