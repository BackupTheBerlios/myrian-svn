//
// Copyright (C) 2001 ArsDigita Corporation. All Rights Reserved.
//
// The contents of this file are subject to the ArsDigita Public 
// License (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of
// the License at http://www.arsdigita.com/ADPL.txt
//
// Software distributed under the License is distributed on an "AS
// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//

model test;

import com.arsdigita.versioning.*;

object type ResourceImpl extends VersionedACSObject { 
    BigDecimal[0..1] parentID    = docs_resources.parent_id;
    String[1..1]     name        = docs_resources.name;
    String[0..1]     description = docs_resources.description;
    Boolean[1..1]    isFolder    = docs_resources.is_folder;
    String[1..1]     path        = docs_resources.path;
  
    reference key (docs_resources.resource_id);
}

// Returns all resources contained within a given folder.

query getResourceTree {
    do {
        select  resource_id,
                name,
                path,
                is_folder,
                level
        from    docs_resources
        start with resource_id = :startFolderID
        connect by prior resource_id = parent_id
    } map {
        id       = resource_id;
        name     = name;
        path     = path;
        isFolder = is_folder;
        level    = level;
    }        
}

// Returns the direct children of a given resource

query getDirectChildren {
    do {
        select  resource_id,
                is_folder
        from    docs_resources
        where   parent_id = :parentID
    } map {
        id       = resource_id;
        isFolder = is_folder;
    }        
}

// Returns a set of resources by path

query getResourceByPath {
    do {
        select resource_id,
               name,
               is_folder,
               path            
        from   docs_resources
        where  path = :targetPath
    } map {
        id   = resource_id;
        isFolder = is_folder;
        name = name;
        path = path;
    }
}

// Returns all path elements of a given resource in reverse order.
// For example, if a resource path is "p1/p2/p3", this query will
// return p3, p2, p1.

query getReversePath {
    do {
        select resource_id,
               parent_id,
               name
        from   docs_resources
        start  with resource_id = :startResourceID
        connect by  resource_id = prior parent_id
    } map {
        id       = resource_id;
        parentID = parent_id;
        name     = name;
    }
}

// retrieve listing of resources that have a given parent

query getChildren {
    do {
        select NVL(d.parent_id,-1) parent_id,      
               d.name,
               d.description,
               d.is_folder,
               d.mime_type,
               nvl(dbms_lob.getlength(d.content),0) sizeBytes,              
               m.label, 
               t.transaction_id,
               t.modifying_user,
               t.modifying_ip,
               to_char(t.timestamp,'MM/DD/YY HH:MI AM') last_modified,
               t.tag,
               a.object_id,
               a.object_type
        from   docs_resources d,
               vc_objects vco,
               acs_objects a, 
               cms_mime_types m, 
               vc_transactions t
        where d.resource_id = vco.object_id
        and   d.resource_id = a.object_id
        and   a.object_id = t.object_id
        and   t.timestamp = (select max(timestamp) 
                               from  vc_transactions 
                               where object_id = a.object_id
                               and d.resource_id = a.object_id)
        and m.mime_type(+) = d.mime_type
        and parent_id = :folderID
        and vco.is_deleted = '0'
        order by d.is_folder, d.name
    } map {
        parentID    =  parent_id;
        name        = d.name;
        description = d.description;
        isFolder    = d.is_folder;
        mimeType    = d.mime_type;
        size        = sizeBytes;
        mimeTypeDescription = m.label;
        transactionID = t.transaction_id;
        modifyingUser = t.modifying_user;
        modifyingIP  = t.modifying_ip;
        lastModified = t.last_modified;
        tag         = t.tag;
        id          = a.object_id;
        objectType  = a.object_type; 
    }
}     

query getRevisionHistory {
    do {
        select   transaction_id,
                 description,
                 tag,
                 timestamp,
                 modifying_user,
                 modifying_ip
        from     vc_transactions
        where    object_id = :resourceID
        order by timestamp
    } map {
        description   = description;
        tag           = tag;
        timestamp     = timestamp;
        modifyingUser = modifying_user;
        modifyingIP   = modifying_ip;
    }
}

// Update the denormalized path for every child of a given resource 

data operation updateChildren {
    do {
        update docs_resources
        set    path = concat(:rootPath, substr(path, :oldRootPathLength))
        where  resource_id in (select resource_id 
                               from   docs_resources
                               start  with resource_id = :parentResource
                               connect by prior resource_id = parent_id)
    }
}


// Retrieve a list of all folders in a certain repository for Copy
// or Move operations.
// This query excludes subfolders of source folders. It excludes
// all(!) children folder(s) of the selected resources (specified
// by the bind variable srcResources).  
query listDestinationFolders {
      do {
         select name, 
                resource_id, 
                nvl(parent_id, -1) parent_id
         from   docs_resources
         where  is_folder='1'
         and    resource_id in (select object_id from vc_objects 
                                where is_deleted = '0')
         and    resource_id not in (select resource_id 
                                    from   docs_resources
                                    start with resource_id in :srcResources
                                    connect by prior resource_id = parent_id)
         start with resource_id = :rootID
         connect by prior resource_id = parent_id
         order by level, name
      } map {
         name = name;
         resourceID = resource_id;
         parentID = parent_id;
      }
}


