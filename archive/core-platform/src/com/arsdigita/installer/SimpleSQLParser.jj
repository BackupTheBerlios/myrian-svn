
options {

    STATIC = false;
    IGNORE_CASE = true;

}


PARSER_BEGIN(SimpleSQLParser) 

package com.arsdigita.installer;

import java.io.*;
import java.lang.reflect.*;

public class SimpleSQLParser {

    private File m_scriptAbsoluteDir;


    public static void main(String args[])
          throws ParseException, IOException, NoSuchMethodException,
                 IllegalAccessException, InvocationTargetException
    {
        SimpleSQLParser parser = new SimpleSQLParser(System.in);
        parser.useSQLStatement(parser, "printStatement");
    }


    SimpleSQLParser (String scriptFilename)
              throws FileNotFoundException {
        this(new FileInputStream(scriptFilename));
        this.m_scriptAbsoluteDir =
              (new File(scriptFilename)).getParentFile().getAbsoluteFile();
    }

    SimpleSQLParser (File scriptFile)
            throws FileNotFoundException {
        this(new FileInputStream(scriptFile));
        this.m_scriptAbsoluteDir =
              scriptFile.getParentFile().getAbsoluteFile();
    }


    //  For static methods
    void useSQLStatement (Class c, String invokingMethodName) 
            throws ParseException, FileNotFoundException, IllegalAccessException,
                   NoSuchMethodException, InvocationTargetException
    {
        Class parameterTypes[] = { String.class };
        Method invokingMethod = c.getMethod(invokingMethodName, parameterTypes);
        useSQLStatement(null, invokingMethod);
    }


    //  Non-static methods must reference object they're dealing with
    void useSQLStatement (Object obj, String invokingMethodName) 
            throws ParseException, FileNotFoundException, IllegalAccessException,
                   NoSuchMethodException, InvocationTargetException
    {
        Class parameterTypes[] = { String.class };
        Method invokingMethod = obj.getClass().getMethod(invokingMethodName, parameterTypes);
        useSQLStatement(obj, invokingMethod);
    }
        

    public void printStatement(String stmt) {
        System.out.println(stmt);
        System.out.println();
    }

        
}

PARSER_END(SimpleSQLParser) 

SKIP:
{
    " "
  | "\n"
  | "\r"
  | "\t"
  | < "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
  | < ( <WHITESPACE> )? "show" <WHITESPACE> "errors"
      ( <WHITESPACE> )? ( <SEMICOLON> )? >
}


TOKEN:
{
    < #WHITESPACE: ( [" ", "\n", "\r", "\t"] )+ >
  | < DOUBLE_AT: "@@" >
  | < STRING_LITERAL: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
  | < DOUBLE_QUOTED_STRING_LITERAL: "\"" (~["\""])* ( "\"\"" (~["\""])* )* "\"" >
  | < PLSQL_BLOCK:  ( <CREATE> <WHITESPACE>
        ( <OR> <WHITESPACE> <REPLACE> <WHITESPACE> )?
        ( <PACKAGE> | <TRIGGER> | <FUNCTION> | <PROCEDURE> ) |
        <BEGIN> | <DECLARE> )
        >
  | < SLASH: ("\n"|"\r"|"\r\n") ( <WHITESPACE> )? "/"  ( <WHITESPACE> )? ("\n"|"\r"|"\r\n") >
  | < #CREATE:  "create" >
  | < #OR:      "or"     >
  | < #REPLACE: "replace" >
  | < #PACKAGE: "package" >
  | < #TRIGGER: "trigger" >
  | < #FUNCTION: "function" >
  | < #PROCEDURE: "procedure" >
  | < #BEGIN: "begin" >
  | < #DECLARE: "declare" >
  | < #END: "end" >
  | < SEMICOLON: ";" >
  | < LANGUAGE: "language" >
  | < LANGUAGE_PHRASE: <LANGUAGE> (<WHITESPACE>)* <STRING_LITERAL>>
  | < SQL_TOKEN: ( ~[" ", "\n", "\r", "\t", ";"] )+ >
}



void useSQLStatement (Object obj, Method invokingMethod) 
        throws FileNotFoundException, 
               IllegalAccessException,
               InvocationTargetException
        :
{
    String s;
    Token includedFileToken;
    String includedFilename;
}
{
        {
        }
  ( <PLSQL_BLOCK>
        {
            Token tok;
            StringBuffer sb = new StringBuffer(token.toString());
            int database = com.arsdigita.db.DbHelper.getDatabase();
            while (true) {
                tok = getNextToken();
                if (tok.kind == SLASH && 
                    database == com.arsdigita.db.DbHelper.DB_ORACLE) {
                    break;
                }
                if (tok.kind == LANGUAGE_PHRASE &&
                    database == com.arsdigita.db.DbHelper.DB_POSTGRES) {
                    sb.append(" ").append(tok.image);
                    // consume the next token which is a semi-colon
                    tok = getNextToken();
                    break;
                }
                sb.append(" ").append(tok.image);
            }

            s = sb.toString();
            Object[] args = { s };
            invokingMethod.invoke(obj, args);
        }
  | <DOUBLE_AT> includedFileToken = <SQL_TOKEN>
        {
            System.err.println();
            includedFilename = includedFileToken.image;
            File includedFile = new File(includedFilename);
            if (includedFile.isAbsolute()) {
                System.err.println("Absolute path found: '" +
                        includedFilename + "'");
            } else {

                String absoluteFilename;

                System.err.println("Relative path found: '" +
                        includedFilename + "'");
                //  Well make it absolute then.
                //  If we don't have information on where we are,
                //  assume that script is located in user current dir.
                if (m_scriptAbsoluteDir == null) {
                    absoluteFilename =
                        System.getProperty("user.dir") +
                        File.separator + includedFilename;
                } else {
                    absoluteFilename =
                        m_scriptAbsoluteDir.toString() +
                        File.separator + includedFilename;
                }

                includedFile = new File(absoluteFilename);

            } 

            System.err.println("Recursively including: '" + 
                    includedFile.toString() + "'");
            SimpleSQLParser parser = new SimpleSQLParser(includedFile);
            parser.useSQLStatement(obj, invokingMethod);

        }
  | s = SQLStatement() <SEMICOLON>
        {
            //  We received a method which should be invoked on passed
            //  object in loop for each SQLStatement s.
            Object[] args2 = { s };
            invokingMethod.invoke(obj, args2);
        }
  )*

    <EOF>
}



String SQLStatement() :
{
    String elem;
    String st="";
}
{
    ( elem=SQLElem()
        {
            st += " " + elem;
        }
    )+
        {
            return st;
        }
}


String SQLElem() :
{
    Token sql;
}
{
    sql = <STRING_LITERAL>
        {
            return sql.image;
        }
    | sql = <DOUBLE_QUOTED_STRING_LITERAL>
        {
            return sql.image;
        }
    | sql = <SQL_TOKEN>
        {
            return sql.image;
        }
}

