
options {

    STATIC = false;
    IGNORE_CASE = true;

}


PARSER_BEGIN(SimpleSQLParser) 

package com.arsdigita.installer;

import java.io.*;
import java.lang.reflect.*;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Logger;

public class SimpleSQLParser {

    private static final Logger s_log =
        Logger.getLogger(SimpleSQLParser.class);

    private File m_scriptAbsoluteDir;
    private File m_scriptRelativeDir;

    // m_scriptAbsoluteDir is used for including files relative to the current
    // working directory.  e.g.) @ create.sql
    //
    // m_scriptRelativeDir is used for including files relative to the current
    // file.  e.g.) @@ create.sql


    public static void main(String args[])
          throws ParseException, IOException, NoSuchMethodException,
                 IllegalAccessException, InvocationTargetException
    {
        ConsoleAppender log = new ConsoleAppender();
        BasicConfigurator.configure(log);

        SimpleSQLParser parser = new SimpleSQLParser(System.in);
        parser.useSQLStatement(parser, "printStatement");
    }


    SimpleSQLParser (String scriptFilename)
              throws FileNotFoundException {
        this(new FileInputStream(scriptFilename));
        this.m_scriptRelativeDir =
              (new File(scriptFilename)).getParentFile().getAbsoluteFile();
        this.m_scriptAbsoluteDir = this.m_scriptRelativeDir;
    }

    SimpleSQLParser (File scriptFile)
            throws FileNotFoundException {
        this(new FileInputStream(scriptFile));
        this.m_scriptRelativeDir =
              scriptFile.getParentFile().getAbsoluteFile();
        this.m_scriptAbsoluteDir = this.m_scriptRelativeDir;
    }

    SimpleSQLParser (File scriptFile, File absoluteDir)
            throws FileNotFoundException {
        this(new FileInputStream(scriptFile));
        this.m_scriptRelativeDir =
              scriptFile.getParentFile().getAbsoluteFile();
        this.m_scriptAbsoluteDir = absoluteDir;
    }


    //  For static methods
    void useSQLStatement (Class c, String invokingMethodName) 
            throws ParseException, FileNotFoundException, IllegalAccessException,
                   NoSuchMethodException, InvocationTargetException
    {
        Class parameterTypes[] = { String.class };
        Method invokingMethod = c.getMethod(invokingMethodName, parameterTypes);
        useSQLStatement(null, invokingMethod);
    }


    //  Non-static methods must reference object they're dealing with
    void useSQLStatement (Object obj, String invokingMethodName) 
            throws ParseException, FileNotFoundException, IllegalAccessException,
                   NoSuchMethodException, InvocationTargetException
    {
        Class parameterTypes[] = { String.class };
        Method invokingMethod = obj.getClass().getMethod(invokingMethodName, parameterTypes);
        useSQLStatement(obj, invokingMethod);
    }
        

    public void printStatement(String stmt) {
        s_log.info (stmt);
    }

        
}

PARSER_END(SimpleSQLParser) 

SKIP:
{
    " "
  | "\n"
  | "\r"
  | "\t"
  | < "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
  | < ( <WHITESPACE> )? "show" <WHITESPACE> "errors"
      ( <WHITESPACE> )? ( <SEMICOLON> )? >
}


TOKEN:
{
    < #WHITESPACE: ( [" ", "\n", "\r", "\t"] )+ >
  | < SINGLE_AT: "@" >
  | < DOUBLE_AT: "@@" >
  | < INCLUDE_FILE: ( <SINGLE_AT> | <DOUBLE_AT> ) <WHITESPACE> >
  | < STRING_LITERAL: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
  | < DOUBLE_QUOTED_STRING_LITERAL: "\"" (~["\""])* ( "\"\"" (~["\""])* )* "\"" >
  | < PLSQL_BLOCK:  ( <CREATE> <WHITESPACE>
        ( <OR> <WHITESPACE> <REPLACE> <WHITESPACE> )?
        ( <PACKAGE> | <TRIGGER> | <FUNCTION> | <PROCEDURE> ) |
        <BEGIN> | <DECLARE> )
        >
  | < SLASH: ("\n"|"\r"|"\r\n") ( <WHITESPACE> )? "/"  ( <WHITESPACE> )? ("\n"|"\r"|"\r\n") >
  | < #CREATE:  "create" >
  | < #OR:      "or"     >
  | < #REPLACE: "replace" >
  | < #PACKAGE: "package" >
  | < #TRIGGER: "trigger" >
  | < #FUNCTION: "function" >
  | < #PROCEDURE: "procedure" >
  | < #BEGIN: "begin" >
  | < #DECLARE: "declare" >
  | < #END: "end" >
  | < SEMICOLON: ";" >
  | < LANGUAGE: "language" >
  | < LANGUAGE_PHRASE: <LANGUAGE> (<WHITESPACE>)* <STRING_LITERAL>>
  | < SQL_TOKEN: ( ~[" ", "\n", "\r", "\t", ";"] )+ >
}



void useSQLStatement (Object obj, Method invokingMethod) 
        throws FileNotFoundException, 
               IllegalAccessException,
               InvocationTargetException
        :
{
    String s;
    Token includedFileToken;
    Token includedFileTypeToken;
    String includedFilename;
    String includedFiletype;
}
{
        {
        }
  ( <PLSQL_BLOCK>
        {
            Token tok;
            StringBuffer sb = new StringBuffer(token.toString());
            int database = com.arsdigita.db.DbHelper.getDatabase();
            while (true) {
                tok = getNextToken();
                if (tok.kind == SLASH && 
                    database == com.arsdigita.db.DbHelper.DB_ORACLE) {
                    break;
                }
                if (tok.kind == LANGUAGE_PHRASE &&
                    database == com.arsdigita.db.DbHelper.DB_POSTGRES) {
                    sb.append(" ").append(tok.image);
                    // consume the next token which is a semi-colon
                    tok = getNextToken();
                    break;
                }
                sb.append(" ").append(tok.image);
            }

            s = sb.toString();
            Object[] args = { s };
            invokingMethod.invoke(obj, args);
        }
  | includedFileTypeToken = <INCLUDE_FILE> includedFileToken = <SQL_TOKEN>
        {
            includedFilename = includedFileToken.image;
            includedFiletype = includedFileTypeToken.image;

            s_log.info ("includedFiletype: " + includedFiletype);

            File includedFile = new File(includedFilename);
            if (includedFile.isAbsolute()) {
                s_log.info ("Absolute path found: '" +
                        includedFilename + "'");
            } else {

                String absoluteFilename;
                File basedir;

                s_log.info("Relative path found: '" +
                        includedFilename + "'");
                //  Well make it absolute then.
                //  If we don't have information on where we are,
                //  assume that script is located in user current dir.
                if ( includedFiletype == "@" ) {
                    if (m_scriptRelativeDir == null) {
                        if (m_scriptAbsoluteDir == null) {
                            basedir = new File (System.getProperty("user.dir"));
                        } else {
                            basedir = m_scriptAbsoluteDir;
                        }
                    } else {
                        basedir = m_scriptRelativeDir;
                    }
                } else {
                    if (m_scriptAbsoluteDir == null) {
                        basedir = new File (System.getProperty("user.dir"));
                    } else {
                        basedir = m_scriptAbsoluteDir;
                    }
                }    
                s_log.info ("basedir: " + basedir);
                s_log.info ("includedFilename: " + includedFilename);

                includedFile = new File(basedir.toString() + File.separator + includedFilename);

            } 

            s_log.info("Recursively including: '" + includedFile.toString() + "'");

            SimpleSQLParser parser;
            if ( m_scriptAbsoluteDir == null ) {
                parser = new SimpleSQLParser(includedFile);
            } else { 
                parser = new SimpleSQLParser(includedFile, m_scriptAbsoluteDir);
            }
            
            parser.useSQLStatement(obj, invokingMethod);

        }
  | s = SQLStatement() <SEMICOLON>
        {
            //  We received a method which should be invoked on passed
            //  object in loop for each SQLStatement s.
            Object[] args2 = { s };
            invokingMethod.invoke(obj, args2);
        }
  )*

    <EOF>
}



String SQLStatement() :
{
    String elem;
    String st="";
}
{
    ( elem=SQLElem()
        {
            st += " " + elem;
        }
    )+
        {
            return st;
        }
}


String SQLElem() :
{
    Token sql;
}
{
    sql = <STRING_LITERAL>
        {
            return sql.image;
        }
    | sql = <DOUBLE_QUOTED_STRING_LITERAL>
        {
            return sql.image;
        }
    | sql = <SQL_TOKEN>
        {
            return sql.image;
        }
}

