//
// Copyright (C) 2001 ArsDigita Corporation. All Rights Reserved.
//
// The contents of this file are subject to the ArsDigita Public 
// License (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of
// the License at http://www.arsdigita.com/ADPL.txt
//
// Software distributed under the License is distributed on an "AS
// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//

model com.arsdigita.categorization;

import com.arsdigita.kernel.*;

object type CategoryCategoryMapping {
    BigDecimal[1..1] id    = cat_category_category_map.category_category_map_id;
    Integer[1..1]    sortKey    = cat_category_category_map.sort_key;
    Boolean[1..1]    isDefault  = cat_category_category_map.default_p;
    String[1..1]     relationType = cat_category_category_map.relation_type;

    Category[1..1]   parentCategory =
        join cat_category_category_map.category_id to
             cat_categories.category_id;
    Category[1..1]   object =
        join cat_category_category_map.related_category_id to
             cat_categories.category_id;

    object key (id);

    insert {
        do {
            insert into cat_category_category_map (
                category_category_map_id,
                category_id,
                related_category_id,
                default_p,
                sort_key,
                relation_type
            ) values (
                :id,
                :parentCategory.id,
                :object.id,
                :isDefault,
                (select CASE WHEN :sortKey is null
                             THEN (select CASE WHEN max(sort_key) is null
                                               THEN 0
                                               ELSE max(sort_key)
                                          END + 1
                                     from cat_object_category_map)
                             ELSE :sortKey
                             END
                   from dual),
                :relationType
            )
        }
    }

}


query categoryCategoryMappingQuery {
    BigDecimal categoryID;
    BigDecimal objectID;
    BigDecimal sortKey;
    Boolean isDefault;
    BigDecimal categoryCategoryMapID;
    String relationType;

    do {
        select related_category_id, category_id, category_category_map_id,
               default_p, sort_key, relation_type
        from cat_category_category_map
    } map {
        categoryID = cat_category_category_map.category_id;
        sortKey = cat_category_category_map.sort_key;
        isDefault = cat_category_category_map.default_p;
        objectID = cat_category_category_map.related_category_id;
        categoryCategoryMapID = cat_category_category_map.category_category_map_id;
        relationType = cat_category_category_map.relation_type;
    }
}


query categoryClearDefaultParent {
    do {
        update cat_category_category_map
        set default_p = 'f'
        where category_category_map_id = :id
    }
}


query getRootCategory {
    BigDecimal id;
    String name;
    Integer nchild;

    do {
        select g.name, 
               g.category_id,
               count(sd.category_id) as sub_count
        from cat_categories g,
             cat_category_category_map sd
        where g.category_id = :objectID
          and sd.category_id(+) = g.category_id
        group by g.name, g.category_id
    } map {
        id = g.category_id;
        name = g.name;
        nchild = sub_count;
    }
}


query getSubCategories {
    BigDecimal id;
    String name;
    Integer nchild;
    
    do {
        select g.name,
               g.category_id,
               count(sd2.category_id) as sub_count
        from cat_categories g,  
             cat_category_category_map sd1,
             cat_category_category_map sd2
        where sd1.category_id = :objectID
          and g.category_id = sd1.related_category_id
          and sd2.category_id(+) = sd1.related_category_id
        group by g.name, g.category_id
    } map {
        id = g.category_id;
        name = g.name;
        nchild = sub_count;
    }
}




