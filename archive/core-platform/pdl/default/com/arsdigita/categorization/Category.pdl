//
// Copyright (C) 2001 ArsDigita Corporation. All Rights Reserved.
//
// The contents of this file are subject to the ArsDigita Public 
// License (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of
// the License at http://www.arsdigita.com/ADPL.txt
//
// Software distributed under the License is distributed on an "AS
// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//

model com.arsdigita.categorization;

import com.arsdigita.kernel.*;

// NOTE:
// out of fear of joining with acs_objects to get the objectType property,
// all events that retrieve categories or sorted categories cheat and
// return a hard-coded value for objectType.  In the case of events that
// retrieve objects of type Category, this hardcoded objectType value will
// be wrong for objects whose type is a subtype of Category.  However,
// no one is relying on the java method Category.getSpecificObjectType()
// to return the "right" subtype of Category.  We will introduce a better
// solution in the future.

object type Category extends ACSObject {
    String[0..1] description = cat_categories.description VARCHAR(4000);
    String[1..1] name = cat_categories.name VARCHAR(200);
    Boolean[1..1] isEnabled = cat_categories.enabled_p CHAR(1);
    Boolean[1..1] isAbstract = cat_categories.abstract_p CHAR(1);

    reference key (cat_categories.category_id);
}


association {
    Category[0..n] categories = join acs_objects.object_id 
                                  to cat_object_category_map.object_id,
                                join cat_object_category_map.category_id
                                  to cat_categories.category_id;
    ACSObject[0..n] childObjects = join cat_categories.category_id
                                    to cat_object_category_map.category_id,
                                  join cat_object_category_map.object_id
                                     to acs_objects.object_id;
    Boolean[0..1] isDefault = cat_object_category_map.default_p; 
    BigDecimal[0..1] sortKey = cat_object_category_map.sort_key;

    add categories {
        do {
            insert into cat_object_category_map (
                category_id,
                object_id,
                default_p,
                sort_key
            ) values (
                :categories.id,
                :id,
                :isDefault,
                (select CASE WHEN (:sortKey is null) THEN 
                            (select CASE WHEN (max(sort_key) is null)
                                               THEN 
                                                0 
                                               ELSE 
                                                max(sort_key)
                                          END + 1 
                                     from cat_object_category_map) 
                             ELSE 
                                 (:sortKey)
                             END
                   from dual)
            )
        }
    } 

    add childObjects {
        do {
            insert into cat_object_category_map (
                category_id,
                object_id,
                default_p,
                sort_key
            ) values (
                :id,
                :childObjects.id,
                :isDefault,
                (select CASE WHEN (:sortKey is null) THEN 
                            (select CASE WHEN (max(sort_key) is null)
                                               THEN 
                                                0 
                                               ELSE 
                                                max(sort_key)
                                          END + 1 
                                     from cat_object_category_map) 
                             ELSE 
                                 (:sortKey)
                             END
                   from dual)
            )
        }
    } 
}



// this returns all related categories (both ways)
// To get the children, do 'get("related")' and then filter on 
// the relationType link attribute to be "child"
// To get the related, do 'get("related")' and then filter on 
// the relationType link attribute to be "related"

association {
    Category[0..n] parents = join cat_categories.category_id
                              to cat_category_category_map.related_category_id,
                             join cat_category_category_map.category_id
                               to cat_categories.category_id;

    Category[0..n] related = join cat_categories.category_id
                              to cat_category_category_map.category_id,
                             join cat_category_category_map.related_category_id
                              to cat_categories.category_id;
    BigDecimal[0..1] sortKey = cat_category_category_map.sort_key;
    Boolean[0..1] isDefault = cat_category_category_map.default_p;
    String[0..1] relationType = cat_category_category_map.relation_type;


    add parents {
        do {
            insert into cat_category_category_map (
                category_id,
                related_category_id,
                default_p,
                sort_key,
                relation_type
            ) values (
                :parents.id,
                :id,
                :isDefault,
                (select CASE WHEN (:sortKey is null) THEN
                             (select CASE WHEN (max(sort_key) is null) THEN
                                               0
                                               ELSE 
                                               max(sort_key)
                                          END + 1
                                     from cat_category_category_map)
                             ELSE 
                                 (:sortKey)
                             END
                   from dual),
                :relationType
            )
        }
    }

    add related {
        do {
            insert into cat_category_category_map (
                category_id,
                related_category_id,
                default_p,
                sort_key,
                relation_type
            ) values (
                :id,
                :related.id,
                :isDefault,
                (select CASE WHEN (:sortKey is null) THEN 
                            (select CASE WHEN (max(sort_key) is null)
                                               THEN 
                                                0 
                                               ELSE 
                                                max(sort_key)
                                          END + 1 
                                     from cat_category_category_map) 
                             ELSE 
                                 (:sortKey)
                             END
                   from dual),
                :relationType
            )
        }
    }
}


// This returns all of the ACSObjects within the subtree for 
// a given category
// no depth on this one, because the 
// same category might appear multiple times
// at different levels.
query objectsInSubtree {
    ACSObject object;

    do {
        select acs_objects.object_id, 
               object_type,
               display_name,
               default_domain_class
          from acs_objects, 
               (select :categoryID as related_category_id from dual
                union all
                select distinct related_category_id 
                           from (select related_category_id, 
                                        category_id 
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                     connect by prior related_category_id = category_id
                     start with category_id = :categoryID) categories,
               cat_object_category_map map
         where acs_objects.object_id = map.object_id
               and categories.related_category_id = map.category_id
    } map {
        object.id = acs_objects.object_id;
        object.objectType = acs_objects.object_type;
        object.displayName = acs_objects.display_name;
        object.defaultDomainClass = acs_objects.default_domain_class;
    }
}


// This walks down the categorization tree and
// returns child categories, including the current
// category.
// See explanation for all the subselects in
// defaultAncestors, same ideas here.
// TODO: rethink selecting sort_key as 0.  Problem is that
// this category may have no children, so we can't just
// select the sort_key out from cat_category_category_map.
// May be worth changing with a min and a nvl or select case when.
// May be worth leaving at 0.  -DEE 7/25/01
query categorySubtree {
    Category categorySubtree;
    BigDecimal level;
    BigDecimal sortKey;
    do {
          select map.depth, c.category_id, c.name, c.description, 
                 c.enabled_p, map.sort_key, 
                 'com.arsdigita.categorization.Category' as object_type, 
                 c.abstract_p
            from (select 0 as depth, 0 as sort_key, :id as related_category_id 
                        from dual
                  union all
                  select level as depth, sort_key, related_category_id
                           from (select related_category_id,
                                        category_id, sort_key    
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                             connect by prior related_category_id = 
                                        category_id 
                             start with category_id = :id) map, 
                 cat_categories c
           where (c.category_id = map.related_category_id)
    } map {
        categorySubtree.id = category_id;
        categorySubtree.name = name;
        categorySubtree.description = description;
        categorySubtree.isEnabled = enabled_p;
        categorySubtree.isAbstract = abstract_p;
        categorySubtree.objectType = object_type;
        sortKey = sort_key;
        level = depth;
    }
}


// This gets the subtree from the specifid root, except for the
// subtree of the current category (elements in the current 
// category's subtree would lead to a loop in the DAG, so they
// aren't valid parents).
// TODO: I would like to move this MINUS into the inner level, in
// order to allow for selecting out DEPTH (to be used as a link
// attribute at some point), but I can't figure out how to.
// In particular, ORA-01472 keeps you from doing a connect by
// on a view containing MINUS, among other things, and ORA-01473 
// disallows subqueries in a connect by so I can't do a where not
// exists either.

// TODO: I can't figure out how to support sort_key here because
// it breaks the minus.  For now, we're just not sorting when
// using this query.
query validParents {
    Category validParent;
    do {
          select category_id, name, description, enabled_p, abstract_p,
                 'com.arsdigita.categorization.Category' as object_type
            from (select 0 as depth, 
                         :rootID as related_category_id 
                    from dual
                  union all
                  select level as depth, related_category_id
                           from (select related_category_id, category_id
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                             connect by prior related_category_id = 
                                        category_id 
                             start with category_id = :rootID) map, 
                 cat_categories c
           where (c.category_id = map.related_category_id)
          MINUS
          select category_id, name, description, enabled_p, abstract_p,
                 'com.arsdigita.categorization.Category' as object_type
            from (select 0 as depth, 
                         :id as related_category_id 
                    from dual
                  union all
                  select level as depth, related_category_id
                           from (select related_category_id, category_id
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                             connect by prior related_category_id = 
                                        category_id 
                             start with category_id = :id) map, 
                 cat_categories c
           where (c.category_id = map.related_category_id)
    } map {
        validParent.id = c.category_id;
        validParent.name = c.name;
        validParent.description = c.description;
        validParent.isEnabled = c.enabled_p;
        validParent.isAbstract = c.abstract_p;
        validParent.objectType = c.object_type;
    }
}




// This walks up the categorization tree and
// returns ancestors, including the current
// category.
//
// The outermost level of nesting is so that filters can still be 
// applied to the whole thing; without it the filter only applies 
// to the second part of the union.  The union is just to pull in 
// the current category.  The innermost subselect is to filter out 
// non-default categories before the connect by, so that in the 
// hierarchy "A (default parent of) B (non-default parent of) C", 
// asking for C's default parents will not list A because B isn't 
// a default parent.
query defaultAncestors {
    Category defaultAncestor;
    BigDecimal level;
 
    do {
        select map.depth, c.name, c.description, c.enabled_p, c.category_id,
               'com.arsdigita.categorization.Category' as object_type, abstract_p
          from
          (select 0 as depth, :id as category_id from dual
           union all
           select level as depth, category_id 
             from (select category_id, 
                          related_category_id 
                     from cat_category_category_map
                    where default_p = 1
                          and relation_type = 'child')
          connect by prior category_id = related_category_id
       start with related_category_id = :id) map,
          cat_categories c
         where (c.category_id = map.category_id)
       order by map.depth desc
    } map {
        defaultAncestor.name = c.name;
        defaultAncestor.description = c.description;
        defaultAncestor.isEnabled = c.enabled_p;
        defaultAncestor.isAbstract = c.abstract_p;
        defaultAncestor.id = c.category_id;
        defaultAncestor.objectType = object_type;
        level = c.depth;
    }
}


query topLevelCategories {
    Category category;
    do {
        select category_id, description, name, enabled_p, abstract_p
        from cat_categories
        where category_id not in (
            select related_category_id
            from cat_category_category_map
            where relation_type = 'child'
        )
    } map {
        category.id = category.category_id;
        category.description = cat_categories.description;
        category.name = cat_categories.name;
        category.isEnabled = cat_categories.enabled_p;
        category.isAbstract = cat_categories.abstract_p;
    }
}


data operation swapCategoryWithNextCategory {
    do {
        update cat_category_category_map 
        set sort_key = decode(sort_key, 
                              :sortKey, :nextSortKey, :nextSortKey, :sortKey) 
        where (sort_key = :sortKey or sort_key = :nextSortKey)
        and category_id = :parentID
        and 2 = (select count(*) from cat_category_category_map 
                 where (sort_key = :sortKey or sort_key = :nextSortKey)
                 and category_id = :parentID)
    }
}

data operation swapObjectWithNextObject {
    do {
        update cat_object_category_map 
        set sort_key = decode(sort_key, 
                              :sortKey, :nextSortKey, :nextSortKey, :sortKey) 
        where (sort_key = :sortKey or sort_key = :nextSortKey)
        and category_id = :parentID
        and 2 = (select count(*) from cat_object_category_map 
                 where (sort_key = :sortKey or sort_key = :nextSortKey)
                 and category_id = :parentID)
    }
}


///////////////////////////////////////////////////////
query getRootCategory {
    BigDecimal id;
    String name;
    BigDecimal nchild;

    do {
        select g.name, 
               g.category_id,
               count(sd.category_id) as sub_count
        from cat_categories g,
             cat_category_category_map sd
        where g.category_id = :objectID
          and sd.category_id(+) = g.category_id
        group by g.name, g.category_id
    } map {
        id = g.category_id;
        name = g.name;
        nchild = sub_count;
    }
}

query getSubCategories {
    BigDecimal id;
    String name;
    BigDecimal nchild;
    
    do {
        select g.name,
               g.category_id,
               count(sd2.category_id) as sub_count
        from cat_categories g,  
             cat_category_category_map sd1,
             cat_category_category_map sd2
        where sd1.category_id = :objectID
          and g.category_id = sd1.related_category_id
          and sd2.category_id(+) = sd1.related_category_id
        group by g.name, g.category_id
    } map {
        id = g.category_id;
        name = g.name;
        nchild = sub_count;
    }
}
