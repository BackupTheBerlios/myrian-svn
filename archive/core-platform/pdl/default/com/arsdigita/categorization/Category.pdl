//
// Copyright (C) 2001 ArsDigita Corporation. All Rights Reserved.
//
// The contents of this file are subject to the ArsDigita Public 
// License (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of
// the License at http://www.arsdigita.com/ADPL.txt
//
// Software distributed under the License is distributed on an "AS
// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//

model com.arsdigita.categorization;

import com.arsdigita.kernel.*;

// NOTE:
// out of fear of joining with acs_objects to get the objectType property,
// all events that retrieve categories or sorted categories cheat and
// return a hard-coded value for objectType.  In the case of events that
// retrieve objects of type Category, this hardcoded objectType value will
// be wrong for objects whose type is a subtype of Category.  However,
// no one is relying on the java method Category.getSpecificObjectType()
// to return the "right" subtype of Category.  We will introduce a better
// solution in the future.

object type Category extends ACSObject {
    // "SortedCategory" is a temporary workaround for the lack of link attributes.
    composite SortedCategory[0..n] relatedCategories;
    composite CategoryCategoryMapping[0..n] childCategoryAssociations;

    composite SortedACSObject[0..n] childObjects;
    composite ObjectCategoryMapping[0..n]  childObjectAssociations;
    composite CategoryCategoryMapping[0..n]  categoryParentCategoryAssociations;
    composite CategoryCategoryMapping[0..n]  categoryRelatedCategoryAssociations;
    composite SortedCategory[0..n]  categorySubtree;
    composite ACSObject[0..n]  objectSubtree;
    composite Category[0..n]  defaultAncestors;
    composite Category[0..n]  validParents;
    composite SortedCategory[0..n]  immediateParents;

    String[0..1] description = cat_categories.description VARCHAR(4000);
    String[1..1] name = cat_categories.name VARCHAR(200);
    Boolean[1..1] isEnabled = cat_categories.enabled_p CHAR(1);
    Boolean[1..1] isAbstract = cat_categories.abstract_p CHAR(1);

    reference key (cat_categories.category_id);

    delete {
        do {    
            delete from cat_category_category_map
            where category_id = :id
        }
        do {
            delete from cat_categories 
            where category_id = :id
        }
        super;
    }


    // this will return all child categories of the passed in category
    // :relationType should be set to 'child' or 'related'
    // NOTE: this relies on acs_object
    retrieve relatedCategories {
        do {
            select m.category_category_map_id,
                   c.category_id, c.name, c.enabled_p,
                   c.description, m.default_p,
                   m.sort_key,
                   'com.arsdigita.categorization.SortedCategory' as object_type,
                   c.abstract_p
             from cat_category_category_map m, cat_categories c
            where c.category_id = m.related_category_id
              and m.category_id = :id
              and m.relation_type = :relationType
        } map {
            relatedCategories.id = category_id;
            relatedCategories.name = name;
            relatedCategories.description = description;
            relatedCategories.isEnabled = enabled_p;
            relatedCategories.isAbstract = abstract_p;
            relatedCategories.sortKey = sort_key;
            relatedCategories.objectType = object_type;
        }
    }

    retrieve childObjects {
        do {
            select acs_objects.object_id,
                   object_type, m.sort_key
              from acs_objects,
                   cat_object_category_map m
             where acs_objects.object_id = m.object_id
               and m.category_id = :id
        } map {
            childObjects.id = acs_objects.object_id;
            childObjects.objectType = acs_objects.object_type;
            childObjects.sortKey = m.sort_key;
        }
    }


    // this will return all child objects (not categories) 
    // of the passed in category
    retrieve childCategoryAssociations {
        do {
            select related_category_id, default_p, sort_key, 
                   category_category_map_id, category_id, relation_type
             from cat_category_category_map 
            where category_id = :id
              and relation_type = 'child'
        } map {
            childCategoryAssociations.id = cat_category_category_map.category_category_map_id;
            childCategoryAssociations.object.id = cat_category_category_map.related_category_id;
            childCategoryAssociations.parentCategory.id = cat_category_category_map.category_id;
            childCategoryAssociations.isDefault = cat_category_category_map.default_p;
            childCategoryAssociations.sortKey = cat_category_category_map.sort_key;
            childCategoryAssociations.relationType = cat_category_category_map.relation_type;
        }
    }


    // this will return all child objects (not categories) 
    // of the passed in category
    retrieve childObjectAssociations {
        do {
            select object_id, default_p, sort_key, 
                   object_category_map_id, category_id
             from cat_object_category_map 
            where category_id = :id
        } map {
            childObjectAssociations.id = cat_object_category_map.object_category_map_id;
            childObjectAssociations.parentCategory.id = cat_object_category_map.category_id;
            childObjectAssociations.object.id = cat_object_category_map.object_id;
            childObjectAssociations.isDefault = cat_object_category_map.default_p;
            childObjectAssociations.sortKey = cat_object_category_map.sort_key;
        }
    }


    // this returns all parent categories for categories
    retrieve categoryParentCategoryAssociations {
        do {
            select related_category_id, default_p,
                   sort_key, category_category_map_id, category_id, 
                   relation_type
             from cat_category_category_map
            where related_category_id = :id
              and relation_type = 'child'
        } map {
            categoryParentCategoryAssociations.id = category_category_map_id;
            categoryParentCategoryAssociations.parentCategory.id = category_id;
            categoryParentCategoryAssociations.object.id = related_category_id;
            categoryParentCategoryAssociations.isDefault = default_p;
            categoryParentCategoryAssociations.sortKey = sort_key;
            categoryParentCategoryAssociations.relationType = relation_type;
        }
    }

    // this returns all related categories (both ways)
    retrieve categoryRelatedCategoryAssociations {
        do {
            select related_category_id, category_id, default_p,
                   sort_key, category_category_map_id, relation_type
             from cat_category_category_map
            where related_category_id = :id
              and relation_type = 'related'
            union
            select category_id, related_category_id, default_p,
                   sort_key, category_category_map_id, relation_type
             from cat_category_category_map
            where category_id = :id
              and relation_type = 'related'
        } map {
            categoryRelatedCategoryAssociations.id = category_category_map_id;
            categoryRelatedCategoryAssociations.isDefault = default_p;
            categoryRelatedCategoryAssociations.sortKey = sort_key;
            categoryRelatedCategoryAssociations.relationType = relation_type;
        }
    }

    // This walks down the categorization tree and
    // returns child categories, including the current
    // category.
    // See explanation for all the subselects in
    // defaultAncestors, same ideas here.
    // TODO: rethink selecting sort_key as 0.  Problem is that
    // this category may have no children, so we can't just
    // select the sort_key out from cat_category_category_map.
    // May be worth changing with a min and a nvl or select case when.
    // May be worth leaving at 0.  -DEE 7/25/01
    retrieve categorySubtree {
        do {
          select map.depth, c.category_id, c.name, c.description, c.enabled_p, map.sort_key, 'com.arsdigita.categorization.SortedCategory' as object_type, c.abstract_p
            from (select 0 as depth, 0 as sort_key, :id as related_category_id from dual
                  union all
                  select level as depth, sort_key, related_category_id
                           from (select related_category_id,
                                        category_id, sort_key    
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                             connect by prior related_category_id = 
                                        category_id 
                             start with category_id = :id) map, 
                 cat_categories c
           where (c.category_id = map.related_category_id)
        } map {
          categorySubtree.id = category_id;
          categorySubtree.name = name;
          categorySubtree.description = description;
          categorySubtree.isEnabled = enabled_p;
          categorySubtree.isAbstract = abstract_p;
          categorySubtree.sortKey = sort_key;
          categorySubtree.objectType = object_type;
          // XXX not yet implemented    link.level = depth;
        }
    }

    // This gets the subtree from the specifid root, except for the
    // subtree of the current category (elements in the current 
    // category's subtree would lead to a loop in the DAG, so they
    // aren't valid parents).
    // TODO: I would like to move this MINUS into the inner level, in
    // order to allow for selecting out DEPTH (to be used as a link
    // attribute at some point), but I can't figure out how to.
    // In particular, ORA-01472 keeps you from doing a connect by
    // on a view containing MINUS, among other things, and ORA-01473 
    // disallows subqueries in a connect by so I can't do a where not
    // exists either.

    // TODO: I can't figure out how to support sort_key here because
    // it breaks the minus.  For now, we're just not sorting when
    // using this query.
    retrieve validParents {
        do {
          select category_id, name, description, enabled_p, abstract_p,
                 'com.arsdigita.categorization.Category' as object_type
            from (select 0 as depth, 
                         :rootID as related_category_id 
                    from dual
                  union all
                  select level as depth, related_category_id
                           from (select related_category_id, category_id
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                             connect by prior related_category_id = 
                                        category_id 
                             start with category_id = :rootID) map, 
                 cat_categories c
           where (c.category_id = map.related_category_id)
          MINUS
          select category_id, name, description, enabled_p, abstract_p,
                 'com.arsdigita.categorization.Category' as object_type
            from (select 0 as depth, 
                         :id as related_category_id 
                    from dual
                  union all
                  select level as depth, related_category_id
                           from (select related_category_id, category_id
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                             connect by prior related_category_id = 
                                        category_id 
                             start with category_id = :id) map, 
                 cat_categories c
           where (c.category_id = map.related_category_id)
        } map {
          validParents.id = c.category_id;
          validParents.name = c.name;
          validParents.description = c.description;
          validParents.isEnabled = c.enabled_p;
          validParents.isAbstract = c.abstract_p;
          validParents.objectType = c.object_type;
        }
    }

    retrieve immediateParents {
        do {
            select m.category_category_map_id,
                   c.category_id, c.name, c.enabled_p, c.abstract_p,
                   c.description, m.default_p,
                   m.sort_key,
                   'com.arsdigita.categorization.SortedCategory' as object_type
             from cat_category_category_map m, cat_categories c
            where c.category_id = m.category_id
              and m.related_category_id = :id
              and m.relation_type = 'child'
        } map {
            immediateParents.id = category_id;
            immediateParents.name = name;
            immediateParents.description = description;
            immediateParents.isEnabled = enabled_p;
            immediateParents.sortKey = sort_key;
            immediateParents.objectType = object_type;
            immediateParents.isAbstract = abstract_p;
        }
    }

//          select l, category_id, name, description, enabled_p from (
//                select 0 as l, c.category_id, c.name, c.description, c.enabled_p
//                   from cat_categories c 
//                  where c.category_id = :id
//                 union all
//                 select l, c.category_id, c.name, c.description, c.enabled_p 
//                   from (select level l, related_category_id
//                           from (select related_category_id, category_id
//                                   from cat_category_category_map 
//                                  where relation_type = 'child')
//                             connect by prior related_category_id = 
//                                        category_id 
//                             start with category_id = :id) m, 
//                        cat_categories c
//                  where (c.category_id = m.related_category_id)) c


    // no depth on this one, because the 
    // same category might appear multiple times
    // at different levels.
    retrieve objectSubtree {
      do {
        select acs_objects.object_id, 
               object_type 
          from acs_objects, 
               (select :id as related_category_id from dual
                union all
                select distinct related_category_id 
                           from (select related_category_id, 
                                        category_id 
                                   from cat_category_category_map 
                                  where relation_type = 'child')
                     connect by prior related_category_id = category_id
                     start with category_id = :id) categories,
               cat_object_category_map map
         where acs_objects.object_id = map.object_id
               and categories.related_category_id = map.category_id
        } map {
            objectSubtree.id = object_id;
            objectSubtree.objectType = object_type;
        }
    }
//          select acs_objects.object_id,
//                 acs_objects.object_type
//              from acs_objects,
//                   cat_object_category_map
//             where acs_objects.object_id = cat_object_category_map.object_id
//               and exists (select category_id
//                    from (
//                 select 0 as l, c.category_id, c.name, c.description, c.enabled_p
//                   from cat_categories c 
//                  where c.category_id = :id
//                 union all
//                 select l, c.category_id, c.name, c.description, c.enabled_p 
//                   from (select level l, related_category_id
//                           from (select related_category_id, category_id
//                                   from cat_category_category_map 
//                                  where relation_type = 'child')
//                             connect by prior related_category_id = 
//                                        category_id 
//                             start with category_id = :id) m, 
//                        cat_categories c
//                  where (c.category_id = m.related_category_id))
//                    where category_id = cat_object_category_map.category_id);


    // This walks up the categorization tree and
    // returns ancestors, including the current
    // category.
    //
    // The outermost level of nesting is so that filters can still be 
    // applied to the whole thing; without it the filter only applies 
    // to the second part of the union.  The union is just to pull in 
    // the current category.  The innermost subselect is to filter out 
    // non-default categories before the connect by, so that in the 
    // hierarchy "A (default parent of) B (non-default parent of) C", 
    // asking for C's default parents will not list A because B isn't 
    // a default parent.
    retrieve defaultAncestors {
      do {
        select map.depth, c.name, c.description, c.enabled_p, c.category_id,
               'com.arsdigita.categorization.Category' as object_type, abstract_p
          from
          (select 0 as depth, :id as category_id from dual
           union all
           select level as depth, category_id 
             from (select category_id, 
                          related_category_id 
                     from cat_category_category_map
                    where default_p = 1
                          and relation_type = 'child')
          connect by prior category_id = related_category_id
       start with related_category_id = :id) map,
          cat_categories c
         where (c.category_id = map.category_id)
       order by map.depth desc
      } map {
        defaultAncestors.name = c.name;
        defaultAncestors.description = c.description;
        defaultAncestors.isEnabled = c.enabled_p;
        defaultAncestors.isAbstract = c.abstract_p;
        defaultAncestors.id = c.category_id;
        defaultAncestors.objectType = object_type;
        // XXX not yet implemented   link.level = c.depth;
      }
    }
//        select c.depth, c.name, c.description, c.enabled_p, c.category_id,
//               c.category_category_map_id, abstract_p from
//          (select 0 as depth, c.name, c.description, c.enabled_p,
//                  c.category_id, TO_NUMBER(null) as category_category_map_id,
//                  abstract_p
//             from cat_categories c 
//            where c.category_id = :id
//           union all
//           select depth, c.name,
//                  c.description,
//                  c.enabled_p,
//                  c.category_id,
//                  m.category_category_map_id
//             from (select level as depth, category_id, 
//                          category_category_map_id,
//                          related_category_id, 
//                     from (select category_id, 
//                                  category_category_map_id,
//                                  related_category_id 
//                             from cat_category_category_map
//                            where default_p = 1
//                              and relation_type = 'child')
//               connect by prior category_id = related_category_id
//               start with related_category_id = :id) m,
//                  cat_categories c
//            where (c.category_id = m.category_id)) c

}

//association {
//    Category[0..n] relaters;
//    Category[0..n] relations;
//
//    Integer[1..1] sortKey;
//    String[1..1] relationType;
//
//    retrieve relations {
//        do {
//            select r.*, 'com.arsdigita.categorization.Category' as type,
//                   m.sort_key, m.relation_type
//            from cat_category_category_map m, cat_categories r
//            where m.category_id = :relaters.id
//            and m.related_category_id = r.category_id
//        } map {
//            relations.id = r.category_id;
//            relations.objectType = type;
//            relations.name = r.name;
//            relations.description = r.description;
//            relations.isEnabled = r.enabled_p;
//            relations.isAbstract = r.abstract_p;
//            sortKey = m.sort_key;
//            relationType = m.relation_type;
//        }
//    }
//}

query getCategories {
    BigDecimal id;
    String name;
    String description;
    do {
        select category_id, name, description
        from cat_categories
     } map {
          id = cat_categories.category_id;
          name = cat_categories.name;
          description = cat_categories.description;
     }
}                       

query topLevelCategories {
    Category category;
    do {
        select category_id, description, name, enabled_p, abstract_p
        from cat_categories
        where category_id not in (
            select related_category_id
            from cat_category_category_map
            where relation_type = 'child'
        )
    } map {
        category.id = category.category_id;
        category.description = cat_categories.description;
        category.name = cat_categories.name;
        category.isEnabled = cat_categories.enabled_p;
        category.isAbstract = cat_categories.abstract_p;
    }
}

query immediateChildren {
    BigDecimal id;
    String name;
    String description;
    do {
        select c.category_id, c.description, c.name
        from cat_categories c, cat_category_category_map ccm
        where ccm.related_category_id = c.category_id
          and ccm.relation_type = 'child'
          and ccm.category_id = :categoryID
    } map {
        id = c.category_id;
        description = c.description;
        name = c.name;
    }
}

object type SortedCategory extends Category {
    Integer[1..1] sortKey;
    
    retrieve {
        do {
            select cat_categories.category_id, 
            acs_objects.object_type as attribute0, 
            acs_objects.display_name as attribute1, 
            acs_objects.default_domain_class as attribute2, 
            cat_categories.description as attribute3, 
            cat_categories.enabled_p as attribute4, abstract_p,
            cat_categories.name as attribute5
            from cat_categories, acs_objects
            where cat_categories.category_id = acs_objects.object_id and
            cat_categories.category_id = :id
        } map {
            id = cat_categories.category_id;
            objectType = acs_objects.attribute0;
            displayName = acs_objects.attribute1;
            defaultDomainClass = acs_objects.attribute2;
            description = cat_categories.attribute3;
            isEnabled = cat_categories.attribute4;
            isAbstract = cat_categories.abstract_p;
            name = cat_categories.attribute5;
        }
    }

    update {
        do {
            
            update object_container_map
            set container_id = :container.id
            where object_id = :id and :container.id is not null
        }
        
        do {
            
            insert into object_container_map
            (object_id, container_id)
            select :id, :container.id
            from dual
            where :container.id is not null
            and not exists (
            select 1 from object_container_map
            where object_id = :id
            )
        }
        
        do {
            
            delete from object_container_map
            where object_id = :id and :container.id is null
        }
        
        do {
            
            update acs_objects 
            set object_type = :objectType,
            display_name = :displayName,
            default_domain_class = :defaultDomainClass
            where object_id = :id
        }
        
        do {
            update cat_categories set 
            enabled_p = :isEnabled,
            abstract_p = :isAbstract,
            name = :name,
            description = :description
            where category_id = :id        
        }
    }
}

object type SortedACSObject extends ACSObject {
    Integer[1..1] sortKey;
}

data operation swapCategoryWithNextCategory {
    do {
        update cat_category_category_map 
        set sort_key = decode(sort_key, 
                              :sortKey, :nextSortKey, :nextSortKey, :sortKey) 
        where (sort_key = :sortKey or sort_key = :nextSortKey)
        and category_id = :parentID
        and 2 = (select count(*) from cat_category_category_map 
                 where (sort_key = :sortKey or sort_key = :nextSortKey)
                 and category_id = :parentID)
    }
}

data operation swapObjectWithNextObject {
    do {
        update cat_object_category_map 
        set sort_key = decode(sort_key, 
                              :sortKey, :nextSortKey, :nextSortKey, :sortKey) 
        where (sort_key = :sortKey or sort_key = :nextSortKey)
        and category_id = :parentID
        and 2 = (select count(*) from cat_category_category_map 
                 where (sort_key = :sortKey or sort_key = :nextSortKey)
                 and category_id = :parentID)
    }
}

query relatedCategoriesQuery {
    Category relatedCategory;
    BigDecimal parentID;
    String relationType;
    Boolean isDefault;
    BigDecimal sortKey;
    
    do {
        select m.category_category_map_id,
               c.category_id as related_id, c.name, c.enabled_p,
               c.description, m.default_p, c.abstract_p,
               m.sort_key,
               'com.arsdigita.categorization.SortedCategory' as object_type,
               m.category_id, m.relation_type
          from cat_category_category_map m, cat_categories c
         where c.category_id = m.related_category_id
    } map {
        relationType = m.relation_type;
        parentID = category_id;
        isDefault = m.default_p;
        relatedCategory.id = c.related_id;
        relatedCategory.name = c.name;
        relatedCategory.description = c.description;
        relatedCategory.isEnabled = c.enabled_p;
        relatedCategory.isAbstract = c.abstract_p;
        sortKey = m.sort_key;
        relatedCategory.objectType = object_type;
    }
}
